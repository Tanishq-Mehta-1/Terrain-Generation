#version 460 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D heightMap;

struct water_drop {
  vec2 pos;
  vec2 dir;
  float speed;
  float water;
  float sediment;
};

uniform float p_inertia;
uniform float p_min_slope;
uniform float p_capacity;
uniform float p_deposition;
uniform float p_erosion;
uniform float p_gravity;
uniform float p_evaporation;
uniform float p_radius;
uniform int p_max_iteration;

bool validCoord(vec2 coord, ivec2 size) {
  return ((coord.x >= 0 && coord.x < size.x) &&
          (coord.y >= 0 && coord.y < size.y));
}

vec4 safeImageLoad(ivec2 coord, ivec2 size) {
  if (!validCoord(coord, size))
    return vec4(1.0f);

  return imageLoad(heightMap, coord);
}

float getHeight(vec2 pos, ivec2 size) {

  ivec2 xy = ivec2(pos);
  if (!validCoord(pos, size))
    return 0.0f;

  float u = (pos - xy).x;
  float v = (pos - xy).y;

  float p_xy = safeImageLoad(xy, size).x;
  float p_xy1 = safeImageLoad(xy + ivec2(0, 1), size).x;
  float p_x1y = safeImageLoad(xy + ivec2(1, 0), size).x;
  float p_x1y1 = safeImageLoad(xy + ivec2(1, 1), size).x;

  return 
  p_x1y1 * u * v + 
  p_x1y * u * (1 - v) + 
  p_xy1 * (1 - u) * v + 
  p_xy * (1 - u) * (1 - v);
}

vec2 getGradient(vec2 pos, ivec2 size) {

  ivec2 xy = ivec2(pos);

  if (!validCoord(pos, size))
    return vec2(0.0f);

  vec2 uv = pos - xy;
  float p_xy = safeImageLoad(xy, size).x;
  float p_xy1 = safeImageLoad(xy + ivec2(0, 1), size).x;
  float p_x1y = safeImageLoad(xy + ivec2(1, 0), size).x;
  float p_x1y1 = safeImageLoad(xy + ivec2(1, 1), size).x;

  vec2 grad;
  grad.x = (p_x1y - p_xy) * (1 - uv.y) + (p_x1y1 - p_xy1) * uv.y;
  grad.y = (p_xy1 - p_xy) * (1 - uv.x) + (p_x1y1 - p_x1y) * uv.x;

  return grad;
}

float erodeTerrain(vec2 pos, ivec2 size, float amount_removed) {

  int radius = int(p_radius);
  float weightSum = 0.0f;
  ivec2 xy = ivec2(pos);

  // calculate weight sum
  for (int dx = -radius; dx <= radius; dx++) {
    for (int dy = -radius; dy <= radius; dy++) {

      if (!validCoord(xy + ivec2(dx, dy), size))
        continue;

      float dist = length(vec2(dx, dy));
      if (dist > radius)
        continue;

      weightSum += max(0.0f, radius - dist);
    }
  }

  if (weightSum <= 0.0f)
    return 0.0f;

  float total_removed = 0.0f;

  // calculate erosion from points
  for (int dx = -radius; dx <= radius; dx++) {
    for (int dy = -radius; dy <= radius; dy++) {

      ivec2 p = xy + ivec2(dx, dy);
      if (!validCoord(p, size))
        continue;

      float dist = length(vec2(dx, dy));
      if (dist > radius)
        continue;

      float w = max(0.0f, radius - dist) / weightSum;
      float erosionFactor = 1.0f;

      float height = imageLoad(heightMap, p).x;
      float removed = amount_removed * w * erosionFactor;

      height = max(0.0f, height - removed);
      imageStore(heightMap, p, vec4(vec3(height), 1.0f));

      total_removed += removed;
    }
  }

  return total_removed; // sediment gained by current point
}

void depositTerrain(vec2 pos, ivec2 size, float amount) {

  ivec2 xy = ivec2(pos);
  vec2 uv = pos - xy;

  // for the 4 pixels of the cell
  float w00 = (1.0 - uv.x) * (1.0 - uv.y);
  float w10 = uv.x * (1.0 - uv.y);
  float w01 = (1.0 - uv.x) * uv.y;
  float w11 = uv.x * uv.y;

  ivec2 xy1 = xy + ivec2(0, 1);
  ivec2 x1y = xy + ivec2(1, 0);
  ivec2 x1y1 = xy + ivec2(1, 1);

  if (validCoord(xy, size))
    imageStore(heightMap, xy,
               imageLoad(heightMap, xy) + vec4(amount * w00, 0, 0, 0));
  if (validCoord(x1y, size))
    imageStore(heightMap, x1y,
               imageLoad(heightMap, x1y) + vec4(amount * w10, 0, 0, 0));
  if (validCoord(xy1, size))
    imageStore(heightMap, xy1,
               imageLoad(heightMap, xy1) + vec4(amount * w01, 0, 0, 0));
  if (validCoord(x1y1, size))
    imageStore(heightMap, x1y1,
               imageLoad(heightMap, x1y1) + vec4(amount * w11, 0, 0, 0));
}

float rand(vec2 xy, float seed){
    return fract(tan(distance(xy * 1.61803398874989484820459, xy) * seed) * xy.x);
}

void main() {

  ivec2 size = imageSize(heightMap);
  ivec2 globalCoord = ivec2(gl_GlobalInvocationID.xy);

  if (rand(globalCoord, 1292.021f) <= 0.8)
    return;

  float posx = globalCoord.x + rand(globalCoord, 1.0f);
  float posy = globalCoord.y + rand(globalCoord, 2.0f);

  water_drop drop;
  drop.pos = vec2(posx - 0.5 , posy - 0.5);
  drop.dir = vec2(0.0, 0.0);
  drop.water = 1.0;
  drop.speed = 1.0;
  drop.sediment = 0.0;

  for (int i = 0; i < p_max_iteration; i++) {

    if (!validCoord(drop.pos, size))
      return;

    if (drop.speed <= 0.01 || drop.water <= 0.01)
        return;

    // calculate gradient of point
    vec2 grad = getGradient(drop.pos, size);
    vec2 dir_new = normalize(mix(normalize(drop.dir), -grad, p_inertia));
    vec2 pos_new = drop.pos + dir_new;

    // calculate height diff
    float height_old = getHeight(drop.pos, size);
    float height_new = getHeight(pos_new, size);
    float height_diff = height_new - height_old;

    // calculate capacity
    float capacity =
        max(-height_diff, p_min_slope) * drop.speed * drop.water * p_capacity;

    // deposit or erode
    float s_diff = drop.sediment - capacity;

    if (s_diff > 0.0f || height_diff >= 0.0f) {

      float amount_deposit =  height_diff >= 0.0f ? min(height_diff, drop.sediment) : s_diff * p_deposition;
      drop.sediment -= amount_deposit;
      depositTerrain(drop.pos, size, amount_deposit);

    } else {
      float amount_eroded = min( -s_diff * p_erosion, -height_diff);
      drop.sediment += erodeTerrain(drop.pos, size, amount_eroded);
    }

    // update other states
    drop.speed = sqrt(drop.speed * drop.speed + height_diff * p_gravity);
    drop.water = drop.water * (1 - p_evaporation);
    drop.pos = pos_new;
    drop.dir = dir_new;
  }
}